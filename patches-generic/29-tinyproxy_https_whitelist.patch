--- /dev/null
+++ b/package/tinyproxy/patches/121-add_https_white_list_filters
@@ -0,0 +1,357 @@
+--- a/src/child.c
++++ b/src/child.c
+@@ -175,6 +175,7 @@ static void child_sighup_handler (int sig)
+ 
+ #ifdef FILTER_ENABLE
+                 filter_reload ();
++		filter_https_reload();
+ #endif /* FILTER_ENABLE */
+         }
+ }
+@@ -441,6 +442,7 @@ void child_main_loop (void)
+ 
+ #ifdef FILTER_ENABLE
+                         filter_reload ();
++			filter_https_reload();
+ #endif /* FILTER_ENABLE */
+ 
+                         /* propagate filter reload to all children */
+--- a/src/conf.c
++++ b/src/conf.c
+@@ -126,6 +126,7 @@ static HANDLE_FUNC (handle_errorfile);
+ static HANDLE_FUNC (handle_addheader);
+ #ifdef FILTER_ENABLE
+ static HANDLE_FUNC (handle_filter);
++static HANDLE_FUNC (handle_filterhttpswhitelist);
+ static HANDLE_FUNC (handle_filtercasesensitive);
+ static HANDLE_FUNC (handle_filterdefaultdeny);
+ static HANDLE_FUNC (handle_filterextended);
+@@ -236,6 +237,7 @@ struct {
+ #ifdef FILTER_ENABLE
+         /* filtering */
+         STDCONF ("filter", STR, handle_filter),
++	STDCONF ("filterhttpswhitelist", STR, handle_filterhttpswhitelist),
+         STDCONF ("filterurls", BOOL, handle_filterurls),
+         STDCONF ("filterextended", BOOL, handle_filterextended),
+         STDCONF ("filterdefaultdeny", BOOL, handle_filterdefaultdeny),
+@@ -291,6 +293,8 @@ static void free_config (struct config_s *conf)
+         safefree (conf->ipAddr);
+ #ifdef FILTER_ENABLE
+         safefree (conf->filter);
++	safefree (conf->filter_httpswhitelist);
++
+ #endif                          /* FILTER_ENABLE */
+ #ifdef REVERSE_SUPPORT
+         free_reversepath_list(conf->reversepath_list);
+@@ -474,6 +478,10 @@ static void initialize_with_defaults (struct config_s *conf,
+                 conf->filter = safestrdup (defaults->filter);
+         }
+ 
++	if(defaults->filter_httpswhitelist) {
++		conf->filter_httpswhitelist = safestrdup(defaults->filter_httpswhitelist);
++	}
++
+         conf->filter_url = defaults->filter_url;
+         conf->filter_extended = defaults->filter_extended;
+         conf->filter_casesensitive = defaults->filter_casesensitive;
+@@ -970,6 +978,11 @@ static HANDLE_FUNC (handle_filterurls)
+         return set_bool_arg (&conf->filter_url, line, &match[2]);
+ }
+ 
++static HANDLE_FUNC (handle_filterhttpswhitelist)
++{
++	return set_string_arg(&conf->filter_httpswhitelist, line, &match[2]);
++}
++
+ static HANDLE_FUNC (handle_filterextended)
+ {
+         return set_bool_arg (&conf->filter_extended, line, &match[2]);
+--- a/src/onf.h
++++ b/src/conf.h
+@@ -49,6 +49,7 @@ struct config_s {
+         char *ipAddr;
+ #ifdef FILTER_ENABLE
+         char *filter;
++ 	char *filter_httpswhitelist;
+         unsigned int filter_url;        /* boolean */
+         unsigned int filter_extended;   /* boolean */
+         unsigned int filter_casesensitive;      /* boolean */
+--- a/src/filter.c
++++ b/src/filter.c
+@@ -41,9 +41,102 @@ struct filter_list {
+ };
+ 
+ static struct filter_list *fl = NULL;
++static struct filter_list *fl_https = NULL;
+ static int already_init = 0;
++static int https_already_init = 0;
+ static filter_policy_t default_policy = FILTER_DEFAULT_ALLOW;
+ 
++
++/*
++ * Initializes a linked list of strings containing https hosts/urls to be filtered
++ */
++void filter_https_init (void)
++{
++        FILE *fd;
++        struct filter_list *p;
++        char buf[FILTER_BUFFER_LEN];
++        char *s;
++        int cflags;
++
++        if (fl_https || https_already_init) {
++                return;
++        }
++
++        fd = fopen (config.filter_httpswhitelist, "r");
++        if (!fd) {
++                return;
++        }
++
++        p = NULL;
++
++        cflags = REG_NEWLINE | REG_NOSUB;
++        if (config.filter_extended)
++                cflags |= REG_EXTENDED;
++        if (!config.filter_casesensitive)
++                cflags |= REG_ICASE;
++
++        while (fgets (buf, FILTER_BUFFER_LEN, fd)) {
++                /*
++                 * Remove any trailing white space and
++                 * comments.
++                 */
++                s = buf;
++                while (*s) {
++                        if (isspace ((unsigned char) *s))
++                                break;
++                        if (*s == '#') {
++                                /*
++                                 * If the '#' char is preceeded by
++                                 * an escape, it's not a comment
++                                 * string.
++                                 */
++                                if (s == buf || *(s - 1) != '\\')
++                                        break;
++                        }
++                        ++s;
++                }
++                *s = '\0';
++
++                /* skip leading whitespace */
++                s = buf;
++                while (*s && isspace ((unsigned char) *s))
++                        s++;
++
++                /* skip blank lines and comments */
++                if (*s == '\0')
++                        continue;
++
++                if (!p) /* head of list */
++                        fl_https = p =
++                            (struct filter_list *)
++                            safecalloc (1, sizeof (struct filter_list));
++                else {  /* next entry */
++                        p->next =
++                            (struct filter_list *)
++                            safecalloc (1, sizeof (struct filter_list));
++                        p = p->next;
++                }
++
++                p->pat = safestrdup (s);
++                p->cpat = (regex_t *) safemalloc (sizeof (regex_t));
++                err = regcomp (p->cpat, p->pat, cflags);
++                if (err != 0) {
++                        fprintf (stderr,
++                                 "Bad regex in %s: %s\n",
++                                 config.filter_httpswhitelist, p->pat);
++                        exit (EX_DATAERR);
++                }
++        }
++        if (ferror (fd)) {
++                perror ("fgets");
++                exit (EX_DATAERR);
++        }
++        fclose (fd);
++
++        https_already_init = 1;
++}
++
++
+ /*
+  * Initializes a linked list of strings containing hosts/urls to be filtered
+  */
+@@ -133,6 +226,25 @@ void filter_init (void)
+         already_init = 1;
+ }
+ 
++
++/* unlink the list */
++void filter_https_destroy (void)
++{
++        struct filter_list *p, *q;
++
++        if (https_already_init) {
++                for (p = q = fl_https; p; p = q) {
++                        regfree (p->cpat);
++                        safefree (p->cpat);
++                        safefree (p->pat);
++                        q = p->next;
++                        safefree (p);
++                }
++                fl_https = NULL;
++                https_already_init = 0;
++        }
++}
++
+ /* unlink the list */
+ void filter_destroy (void)
+ {
+@@ -151,6 +263,19 @@ void filter_destroy (void)
+         }
+ }
+ 
++
++/**
++ * reload the filter file if filtering is enabled
++ */
++void filter_https_reload (void)
++{
++        if (config.filter_httpswhitelist) {
++                log_message (LOG_NOTICE, "Re-reading https whiltelist file.");
++                filter_https_destroy ();
++                filter_https_init ();
++        }
++}
++
+ /**
+  * reload the filter file if filtering is enabled
+  */
+@@ -192,6 +317,33 @@ COMMON_EXIT:
+ }
+ 
+ /* returns 0 to allow, non-zero to block */
++int filter_https_url (const char *url)
++{
++        struct filter_list *p;
++        int result;
++
++        if (!fl_https || !https_already_init)
++                goto COMMON_EXIT;
++
++        for (p = fl_https; p; p = p->next) {
++                result =
++                    regexec (p->cpat, url, (size_t) 0, (regmatch_t *) 0, 0);
++
++                if (result == 0) {
++                	return 1;
++                }
++        }
++
++	return 0;
++
++COMMON_EXIT:
++        if (default_policy == FILTER_DEFAULT_ALLOW)
++                return 0;
++        else
++                return 1;
++}
++
++/* returns 0 to allow, non-zero to block */
+ int filter_url (const char *url)
+ {
+         struct filter_list *p;
+--- a/src/filter.h
++++ b/src/filter.h
+@@ -26,12 +26,15 @@ typedef enum {
+         FILTER_DEFAULT_DENY
+ } filter_policy_t;
+ 
++extern void filter_httpswhitelist_init (void);
+ extern void filter_init (void);
++extern void filter_https_destroy (void);
+ extern void filter_destroy (void);
++extern void filter_https_reload (void);
+ extern void filter_reload (void);
+ extern int filter_domain (const char *host);
+ extern int filter_url (const char *url);
+-
++extern int filter_https_url (const char *url);
+ extern void filter_set_default_policy (filter_policy_t policy);
+ 
+ #endif
+--- a/src/main.c
++++ b/src/main.c
+@@ -398,6 +398,9 @@ main (int argc, char **argv)
+ #ifdef FILTER_ENABLE
+         if (config.filter)
+                 filter_init ();
++
++	if(config.filter_httpswhitelist)
++		filter_https_init();
+ #endif /* FILTER_ENABLE */
+ 
+         /* Start listening on the selected port. */
+@@ -476,6 +479,8 @@ main (int argc, char **argv)
+ #ifdef FILTER_ENABLE
+         if (config.filter)
+                 filter_destroy ();
++	if(config.filter_httpswhitelist)
++		filter_https_destroy ();	
+ #endif /* FILTER_ENABLE */
+ 
+         shutdown_logging ();
+--- a/src/reqs.c
++++ b/src/reqs.c
+@@ -299,6 +299,7 @@ static struct request_s *process_request (struct conn_s *connptr,
+         struct request_s *request;
+         int ret;
+         size_t request_len;
++	int https_connect = 0;
+ 
+         /* NULL out all the fields so frees don't cause segfaults. */
+         request =
+@@ -399,6 +400,10 @@ BAD_REQUEST_ERROR:
+                         goto fail;
+                 }
+ 
++		if(strncasecmp(url, "https://", 8) == 0) {
++			https_connect = 1;				
++		}
++
+                 /* Verify that the port in the CONNECT method is allowed */
+                 if (!check_allowed_connect_ports (request->port,
+                                                   config.connect_ports))
+@@ -433,10 +438,30 @@ BAD_REQUEST_ERROR:
+         }
+ 
+ #ifdef FILTER_ENABLE
+-        /*
++        if(config.filter_httpswhitelist && https_connect == 1){
++		ret = filter_https_url (url);
++
++		if(ret) {
++			update_stats(STAT_DENIED);
++			
++			log_message(LOG_NOTICE,
++				"Proxying refused on filtered https url \"%s\"",
++				url);
++
++                        indicate_http_error (connptr, 403, "Filtered",
++                                             "detail",
++                                             "The request you made has been filtered",
++                                             "url", url, NULL);
++
++			goto fail;
++			
++		} 
++	}
++
++	/*
+          * Filter restricted domains/urls
+          */
+-        if (config.filter) {
++        else if (config.filter) {
+                 if (config.filter_url)
+                         ret = filter_url (url);
+                 else
